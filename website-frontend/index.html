<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Guitar Fretboard Detector</title>
  <style>
    body { font-family: Arial; text-align: center; margin-top: 40px; }
    canvas, img, video { max-width: 100%; border: 1px solid #ccc; margin: 10px 0; }
    .control-section { margin: 20px 0; padding: 20px; border: 1px solid #eee; }
    #scaleControls { margin: 20px 0; }
    .scale-button { margin: 0 5px; padding: 5px 10px; }
    .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               background: rgba(0,0,0,0.7); color: white; padding: 20px; border-radius: 5px; }
  </style>
</head>
<body>
  <div class="control-section">
    <h2>Guitar Fretboard Detector</h2>
    <button id="startWebcam">Start Webcam</button>
    <button id="stopWebcam" style="display:none;">Stop Webcam</button>
    <button id="listDevices">List Available Cameras</button><br>
    <div id="deviceList" style="margin: 10px; text-align: left;"></div>
    <div id="backendStatus" style="margin: 10px; color: red;"></div><br>
    <div id="videoContainer" style="position: relative; display: inline-block;">
      <video id="webcamVideo" autoplay playsinline style="display: none; max-width: 100%; width: 640px; height: 480px; background: #000;"></video>
      <canvas id="resultCanvas" style="display: none; max-width: 100%;"></canvas>
      <div id="loadingIndicator" class="loading" style="display: none;">Processing...</div>
    </div>
  </div>

  <div id="scaleControls">
    <h3>Change Scale</h3>
    <div>
      <button class="scale-button" onclick="changeScale('C', 'major')">C Major</button>
      <button class="scale-button" onclick="changeScale('A', 'minor')">A Minor</button>
      <button class="scale-button" onclick="changeScale('G', 'major')">G Major</button>
      <button class="scale-button" onclick="changeScale('E', 'minor')">E Minor</button>
    </div>
  </div>

  <script>
    let stream = null;
    let isProcessing = false;
    let processingInterval = null;
    const BACKEND_URL = 'http://localhost:5000';
    let backendAvailable = false;

    // Check if backend is available
    async function checkBackend() {
      try {
        const response = await fetch(`${BACKEND_URL}/health`, { method: 'GET' });
        backendAvailable = response.ok;
        updateBackendStatus();
      } catch (err) {
        backendAvailable = false;
        updateBackendStatus();
      }
    }

    function updateBackendStatus() {
      const statusDiv = document.getElementById('backendStatus');
      if (backendAvailable) {
        statusDiv.style.color = 'green';
        statusDiv.innerHTML = 'Backend server is connected';
      } else {
        statusDiv.style.color = 'red';
        statusDiv.innerHTML = 'Backend server is not running. Please start the Python backend server at localhost:5000';
      }
    }

    // Check backend status every 5 seconds
    setInterval(checkBackend, 5000);
    // Initial check
    checkBackend();

    // Function to list available devices
    async function listAvailableDevices() {
      try {
        // Request permission first to get labels
        await navigator.mediaDevices.getUserMedia({ video: true, audio: false })
          .then(tempStream => {
            tempStream.getTracks().forEach(track => track.stop());
          })
          .catch(err => console.log('Permission request failed:', err));

        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        const deviceList = document.getElementById('deviceList');
        if (videoDevices.length === 0) {
          deviceList.innerHTML = 'No video devices found!';
          return;
        }

        deviceList.innerHTML = '<strong>Available Cameras:</strong><br>' +
          videoDevices.map((device, index) => 
            `${index + 1}. ${device.label || 'Unnamed Camera'} (${device.deviceId})`
          ).join('<br>');
      } catch (err) {
        console.error('Error listing devices:', err);
        document.getElementById('deviceList').innerHTML = 'Error listing devices: ' + err.message;
      }
    }

    // Function to force release all media devices
    async function forceReleaseCamera() {
      console.log('Forcing camera release...');
      
      // Stop any existing stream
      if (stream) {
        stream.getTracks().forEach(track => {
          track.stop();
          console.log('Stopped track:', track.kind);
        });
        stream = null;
      }

      // Reset video element
      const video = document.getElementById('webcamVideo');
      if (video) {
        video.srcObject = null;
        video.load();
      }
      
      console.log('Force release completed');
    }

    async function startWebcam() {
      console.log('Starting webcam...');
      
      // Force release camera first
      await forceReleaseCamera();

      // List available devices
      await listAvailableDevices();
      
      // Check if getUserMedia is supported
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        const msg = 'getUserMedia is not supported in this browser';
        console.error(msg);
        alert(msg);
        return;
      }

      try {
        console.log('Requesting webcam access...');
        
        // Get available devices first
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        if (videoDevices.length === 0) {
          throw new Error('No video devices found');
        }

        // Create a timeout promise with longer duration
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Timeout waiting for webcam')), 20000); // 20 seconds timeout
        });

        // Try with specific constraints
        const constraints = {
          video: {
            deviceId: videoDevices[0].deviceId, // Use first available camera
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          },
          audio: false
        };

        console.log('Using constraints:', constraints);

        // Race between getUserMedia and timeout
        stream = await Promise.race([
          navigator.mediaDevices.getUserMedia(constraints),
          timeoutPromise
        ]);

        console.log('Webcam access granted');
        
        const video = document.getElementById('webcamVideo');
        if (!video) {
          throw new Error('Video element not found');
        }

        // Reset any previous state
        video.srcObject = null;
        video.style.display = 'none'; // Hide video until it's ready
        
        // Set up video element
        video.srcObject = stream;
        
        // Wait for video to be ready
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            console.log('Video metadata loaded');
            resolve();
          };
        });

        // Configure video and canvas after metadata is loaded
        video.style.display = 'block';
        
        // Set up canvas
        const canvas = document.getElementById('resultCanvas');
        if (canvas) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          canvas.style.display = 'block';
        }

        // Try to play the video
        await video.play();
        console.log('Video playback started');

        // Update UI buttons
        document.getElementById('startWebcam').style.display = 'none';
        document.getElementById('stopWebcam').style.display = 'inline';
        console.log('UI buttons updated');

        // Start processing automatically
        startProcessing();

      } catch (err) {
        console.error('Webcam error:', err);
        await forceReleaseCamera();
        alert('Error accessing webcam: ' + err.message + '\nPlease check the device list and try again.');
      }
    }

    function stopWebcam() {
      console.log('Stopping webcam...');
      if (stream) {
        stream.getTracks().forEach(track => {
          track.stop();
          console.log('Track stopped:', track.kind);
        });
        stream = null;
      }
      
      const video = document.getElementById('webcamVideo');
      const canvas = document.getElementById('resultCanvas');
      
      if (video) {
        video.srcObject = null;
        video.style.display = 'none';
      }
      
      if (canvas) {
        canvas.style.display = 'none';
      }
      
      document.getElementById('startWebcam').style.display = 'inline';
      document.getElementById('stopWebcam').style.display = 'none';
      stopProcessing();
      console.log('Webcam stopped');
    }

    async function processWebcamFrame() {
      if (!backendAvailable || !stream) {
        console.log('Backend not available or webcam not active, skipping frame processing');
        return;
      }

      // Show loading indicator only if processing takes too long
      let loadingTimeout = setTimeout(() => {
        document.getElementById('loadingIndicator').style.display = 'block';
      }, 500);

      try {
        const video = document.getElementById('webcamVideo');
        const canvas = document.getElementById('resultCanvas');
        const ctx = canvas.getContext('2d');

        // Reduce resolution for better performance
        const scaleFactor = 0.75; // Process at 75% resolution
        const width = video.videoWidth * scaleFactor;
        const height = video.videoHeight * scaleFactor;
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Draw the current video frame at reduced resolution
        ctx.drawImage(video, 0, 0, width, height);

        // Get the frame as base64 with reduced quality
        const imageData = canvas.toDataURL('image/jpeg', 0.8); // 80% quality

        // Send to backend
        const response = await fetch(`${BACKEND_URL}/detect`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ image: imageData })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        if (result.success) {
          // Display the processed image
          const img = new Image();
          img.onload = () => {
            // Make sure canvas is visible
            canvas.style.display = 'block';
            // Hide video element since we're showing processed frames
            video.style.display = 'none';
            
            // Set canvas dimensions to match image
            canvas.width = img.width;
            canvas.height = img.height;
            
            // Clear canvas before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the processed image
            ctx.drawImage(img, 0, 0);
            
            // Add debug info
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, 180, 30);
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(`Frame received: ${new Date().toLocaleTimeString()}`, 5, 20);
            
            // Clear loading timeout and hide indicator
            clearTimeout(loadingTimeout);
            document.getElementById('loadingIndicator').style.display = 'none';
          };
          img.src = result.image;
        }
      } catch (error) {
        console.error('Error processing frame:', error);
        clearTimeout(loadingTimeout);
        document.getElementById('loadingIndicator').style.display = 'none';
        if (!backendAvailable) {
          stopProcessing();
          alert('Backend server is not available. Please start the Python backend server and try again.');
        }
      }
    }

    function startProcessing() {
      if (!backendAvailable) {
        alert('Cannot start processing: Backend server is not running. Please start the Python backend server first.');
        return;
      }

      if (!isProcessing) {
        isProcessing = true;
        // Make canvas visible
        document.getElementById('resultCanvas').style.display = 'block';
        // Hide video element since we're showing processed frames
        document.getElementById('webcamVideo').style.display = 'none';
        
        // Use requestAnimationFrame for smoother performance
        let lastProcessTime = 0;
        const minProcessInterval = 100; // Minimum 100ms between frames
        
        function processLoop(timestamp) {
          if (!isProcessing) return;
          
          // Throttle processing to avoid overloading
          if (timestamp - lastProcessTime >= minProcessInterval) {
            lastProcessTime = timestamp;
            processWebcamFrame();
          }
          
          // Schedule next frame
          requestAnimationFrame(processLoop);
        }
        
        // Start the processing loop
        requestAnimationFrame(processLoop);
        console.log('Started processing with requestAnimationFrame');
      }
    }

    function stopProcessing() {
      if (isProcessing) {
        isProcessing = false;
        if (processingInterval) {
          clearInterval(processingInterval);
          processingInterval = null;
        }
        console.log('Stopped processing');
      }
    }

    async function changeScale(root, scale) {
      try {
        const response = await fetch(`${BACKEND_URL}/change_scale`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ root, scale })
        });

        const result = await response.json();
        if (!result.success) {
          alert('Error changing scale: ' + result.error);
        }
      } catch (error) {
        console.error('Error changing scale:', error);
        alert('Error changing scale');
      }
    }

    // Event listeners for webcam buttons
    document.getElementById('startWebcam').addEventListener('click', startWebcam);
    document.getElementById('stopWebcam').addEventListener('click', stopWebcam);

    // Add event listener for the List Devices button
    document.getElementById('listDevices').addEventListener('click', listAvailableDevices);

    // Add cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });

    // Add cleanup on visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && stream) {
        stopWebcam();
      }
    });
  </script>
</body>
</html>